###练习1
填写alloc_proc函数
```
这个函数的目的是负责分配并初始化一个proc结构体
并对其中的成员变量进行初始化
state=PROC_UNINIT
pid=-1
runs=0
kstack=0
need_resched=0
parent=NULL
mm = 0
context = 0
tf = 0
cr3 = boot_cr3
flags = 0
name = ''

context是程序运行上下文，即各个寄存器的取值,切换进程的时候需要用来保存和恢复上下文

trapframe是中端帧的指针，当进程从用户控件调到内核空间时，中端帧记录了进程在被中断前的状态，当需要跳回用户空间时，需要调整中端帧以恢复让进程继续执行的寄存器值。

```



###练习2
为新创建的内核线程分配资源
```
调用alloc_proc分配一个结构体空间
为进程分配内核栈，调用setup_kstack函数，其实就是分配一块KSTACKSPACE大小的空间
复制原进程的内存管理信息到新进程
复制上下文
将新进程添加到进程列表
唤醒新进程
返回新进程号

每一个新fork的线程的id都是唯一的，由getpid函数中可看出，程序枚举last_pid，然后和进程列表中的pid比较，没有重复则返回。
```

###练习3
proc_run函数的理解
```
这个函数的作用是切换到next进程去执行
第一步，首先是关闭中断

第二步，切换进程指针，
第三步，切换内核堆栈
第四步，载入页表
第五部，载入上下文

最后，重新开启中断

创建和执行了两个内核线程

local_intr_save()
和
local_intr_restore()
两个函数的作用是关闭中断和开启中断

这里关闭中断的作用是确保操作是原子操作，不会被中断打断
```
